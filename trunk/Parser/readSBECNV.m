function [instHeader fileHeader data] = readSBECNV( filename )
%READSBECNV Reads in data from a Seabird .cnv file.
%
% This function is able to read in a converted (.cnv) data file generated by
% the Seabird SBE Data Processing program. SBE Data Processing is able to 
% generate .cnv files from raw .hex and .con files retrieved from Seabird CTD 
% recorders; the resulting .cnv file consists of three sections:
%
%   - raw header       - header information as retrieved from the instrument. 
%                        These lines are prefixed with '*'.
%   - processed header - header information generated by SBE Data Processing. 
%                        These lines are prefixed with '#'.
%   - data             - Rows of space separated data.
%
% Inputs:
%   filename - string containing the path to the input file
%
% Outputs:
%   instHeader - Struct containing instrument header.
%   fileHeader - Struct containing file header.
%   data       - Struct containing data.
%
% Author: Paul McCarthy <paul.mccarthy@csiro.au>
%

%
% Copyright (c) 2009, eMarine Information Infrastructure (eMII) and Integrated 
% Marine Observing System (IMOS).
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without 
% modification, are permitted provided that the following conditions are met:
% 
%     * Redistributions of source code must retain the above copyright notice, 
%       this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright 
%       notice, this list of conditions and the following disclaimer in the 
%       documentation and/or other materials provided with the distribution.
%     * Neither the name of the eMII/IMOS nor the names of its contributors 
%       may be used to endorse or promote products derived from this software 
%       without specific prior written permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
% POSSIBILITY OF SUCH DAMAGE.
%
  error(nargchk(1,1,nargin));

  if ~ischar(filename), error('filename must be a string'); end
  
  % we put the lines from each section into separate cell arrays
  instHeaderLines = {};
  fileHeaderLines = {};
  dataLines       = {};
  
  fid = -1;
  try
    fid = fopen(filename);
    % read in all the lines, putting them 
    % into the appropriate cell array
    line = fgetl(fid);
    
    while ischar(line)
      
      line = deblank(line);
      if isempty(line)
        line = fgetl(fid);
        continue; 
      end
      
      switch line(1)
        case '*',  instHeaderLines{end+1} = line;
        case '#',  fileHeaderLines{end+1} = line;
        otherwise, dataLines      {end+1} = line;
      end
      
      line = fgetl(fid);
    end
    fclose(fid);
    
  catch e
    if fid ~= -1, fclose(fid); end
    rethrow(e);
  end
  
  % parse the various sections
  instHeader = parseInstrumentHeader(instHeaderLines);
  fileHeader = parseFileHeader(fileHeaderLines);
  data       = parseData(dataLines, instHeader, fileHeader);

end

function header = parseInstrumentHeader(headerLines)
%PARSEINSTRUMENTHEADER Parses the header lines from a .cnv file. Returns 
% the header information in a struct.
%
% Inputs:
%   headerLines - cell array of strings, the lines of the header section.
%
% Outputs:
%   header      - struct containing information that was in the header
%                 section.
%
  header = struct;

  % there's no real structure to the header information, which 
  % is annoying. my approach is to use various regexes to search 
  % for info we want, and to ignore everything else. inefficient,
  % but it's the nicest way i can think of
  headerExpr   = '^\*\s*(SBE \S+|SeacatPlus)\s+V\s+(\S+)\s+SERIAL NO.\s+(\d+)';
  scanExpr     = 'number of scans to average = (\d+)';
  memExpr      = 'samples = (\d+), free = (\d+), casts = (\d+)';
  sampleExpr   = ['sample interval = (\d+) (\w+), ' ...
                  'number of measurements per sample = (\d+)'];
  modeExpr     = 'mode = (\w+)';
  pressureExpr = 'pressure sensor = (strain gauge|quartz)';
  voltExpr     = 'Ext Volt (\d+) = (yes|no)';
  outputExpr   = 'output format = (.*)$';
  castExpr     = ['(?:cast|hdr)\s+(\d+)\s+' ...
                  '(\d+ \w+ \d+ \d+:\d+:\d+)\s+'...
                  'samples (\d+) to (\d+), (?:avg|int) = (\d+)'];
  intervalExpr = 'interval = (.*): ([\d\.\+)$';
  
  exprs = {...
    headerExpr   scanExpr     ...
    memExpr      sampleExpr   ...
    modeExpr     pressureExpr ...
    voltExpr     outputExpr   ...
    castExpr     intervalExpr};
  
  for k = 1:length(headerLines)
    
    % try each of the expressions
    for m = 1:length(exprs)
      
      % until one of them matches
      tkns = regexp(headerLines{k}, exprs{m}, 'tokens');
      if ~isempty(tkns)
        
        % yes, ugly, but easiest way to figure out which regex we're on
        switch m
          
          % header
          case 1
            header.instrument_model     = tkns{1}{1};
            header.instrument_firmware  = tkns{1}{2};
            header.instrument_serial_no = tkns{1}{3};
            
          % scan
          case 2
            header.scanAvg = str2double(tkns{1}{1});
          
          % mem
          case 3
            header.numSamples = str2double(tkns{1}{1});
            header.freeMem    = str2double(tkns{1}{2});
            header.numCasts   = str2double(tkns{1}{3});
            
          % sample
          case 4
            header.sampleInterval        = str2double(tkns{1}{1});
            header.mesaurementsPerSample = str2double(tkns{1}{2});
            
          % mode
          case 5
            header.mode = tkns{1}{1};
          
          % pressure
          case 6
            header.pressureSensor = tkns{1}{1};
            
          % volt
          case 7
            for n = 1:length(tkns), 
              header.(['ExtVolt' tkns{n}{1}]) = tkns{n}{2};
            end
            
          % output
          case 8
            header.outputFormat = tkns{1}{1};
            
          % cast
          case 9
            header.castNumber = str2double(tkns{1}{1});
            header.castDate   = datenum(tkns{1}{2}, 'dd mmm yyyy HH:MM:SS');
            header.castStart  = str2double(tkns{1}{3});
            header.castEnd    = str2double(tkns{1}{4});
            header.castAvg    = str2double(tkns{1}{5});
            
          % interval
          case 10
            header.resolution = tkns{1}{1};
            header.interval   = str2double(tkns{1}{2});
        end
        break;
      end
    end
  end
end

function header = parseFileHeader(headerLines)
%PARSEFILEHEADER Parses the data contained inthe file header. This includes
% the column layout of the data in the .cnv file.
%
% Inputs:
%   headerLines - Cell array of strings, the lines in the file header section.
%
% Outputs:
%   header      - struct containing information that was contained in the
%                 file header section.
%

  header = struct;
  header.columns = {};
  
  nameExpr = 'name \d+ = (.+):';
  nvalExpr = 'nvalues = (\d+)';
  badExpr  = 'bad_flag = (.*)$';
  
  for k = 1:length(headerLines)
    
    % try name expr
    tkns = regexp(headerLines{k}, nameExpr, 'tokens');
    if ~isempty(tkns)
      header.columns{end+1} = tkns{1}{1};
      continue; 
    end
    
    % then try nvalues expr
    tkns = regexp(headerLines{k}, nvalExpr, 'tokens');
    if ~isempty(tkns)
      header.nValues = str2double(tkns{1}{1});
      continue;
    end
    
    % then try bad flag expr
    tkns = regexp(headerLines{k}, badExpr, 'tokens');
    if ~isempty(tkns)
      header.badFlag = str2double(tkns{1}{1});
      continue;
    end
  end
end

function data = parseData(dataLines, instHeader, fileHeader)
%PARSEDATA Parses the data section of the .cnv file.
%
% Inputs:
%   dataLines  - cell array of strings, the lines containing the data.
%   instHeader - struct containing instrument header information.
%   fileHeader - struct containing file header information.
%
% Outputs:
%   data       - struct containing the data.
%
  
  data = struct;
  
  format = '';
  
  columns = fileHeader.columns;
  for k = 1:length(columns), format = [format '%n']; end
  
  dataLines = [dataLines{:}];
  
  dataLines = textscan(dataLines, format);
  
  for k = 1:length(columns)
    
    d = dataLines{k};
    d(d == fileHeader.badFlag) = nan;
    
    [n, d] = convertData(genvarname(columns{k}), d, instHeader);
    
    if isempty(n) || isempty(d), continue; end
    
    % if the same parameter appears multiple times, 
    % don't overwrite it in the data struct - append
    % a number to the end of the variable name, as 
    % per the IMOS convention
    count = 0;
    nn = n;
    while isfield(data, nn)
      
      count = count + 1;
      nn = [n '_' num2str(count)];
    end
    
    data.(nn) = d; 
  end
  
  % if there was no time data in the file,
  % generate time stamps for each sample
  if ~isfield(data, 'TIME')
    data.TIME = genTimestamps(instHeader, fileHeader, data);
  end
  
end

function [name, data] = convertData(name, data, instHeader) 
%CONVERTDATA The .cnv file provides data in a bunch of different units of
% measurement. This function is just a big switch statement which takes
% SBE19 data as input, and attempts to convert it to IMOS compliant name and 
% unit of measurement. Returns empty string/vector if the parameter is not 
% supported.
%

  % the cast date, if present, is used for time field offset
  castDate = 0;
  if isfield(instHeader, 'castDate'), castDate = instHeader.castDate; end

  switch name
    
    % elapsed time (seconds since start)
    case 'timeS'
      name = 'TIME';
      data = data / 86400 + castDate;
      
    % elapsed time (minutes since start)
    case 'timeM'
      name = 'TIME';
      data = data / 1440 + castDate;
      
    % elapsed time (hours since start)
    case 'timeH'
      name = 'TIME';
      data = data / 24  + castDate;
    
    % elapsed time (days since start of year)
    case 'timeJ'
      name = 'TIME';
      data = rem(data, floor(data)) + floor(castDate);
    
    % strain gauge pressure (dbar)
    case 'prdM'
      name = 'PRES';
      
    % temperature (deg C)
    case 'tv290C'
      name = 'TEMP';
      
    % conductivity (S/m)
    case 'c0S0x2Fm'
      name = 'CNDC';
    
    % conductivity (mS/cm)
    % mS/cm -> S/m
    case 'c0ms0x2Fcm'
      name = 'CNDC';
      data = data ./ 10;
    
    % conductivity (uS/cm)
    case 'c0us0x2Fcm'
      name = 'CNDC';
      data = data ./ 100000;
    
    % fluorescence (ug/L)
    % ug/L == mg/m^-3
    case 'flC'
      name = 'FLU2';
    
    % fluorescence (mg/m^3)
    case 'flECO0x2DAFL'
      name = 'FLU2';
      
    % oxygen (mg/L)
    % mg/L == kg/m^3
    case 'oxsolMg0x2FL'
      name = 'DOXY';
    
    % oxygen (umol/Kg)
    % umol/Kg -> mol/Kg
    case 'oxsolMm0x2FKg'
      name = 'DOX2';
      data = data ./ 1000000;
      
    % oxygen (mg/L)
    % mg/L == kg/m^3
    case 'oxsatMg0x2FL'
      name = 'DOXY';
      
    % oxygen (umol/Kg)
    % umol/Kg -> mol/Kg
    case 'oxsatMm0x2FKg'
      name = 'DOX2';
      data = data ./ 1000000;
    
    % oxygen (mg/L)
    % mg/L == kg/m^3
    case 'sbeox0Mg0x2FL'
      name = 'DOXY';
      
    % oxygen (umol/Kg)
    % umol/Kg -> mol/Kg
    case 'sbeox0Mm0x2FKg'
      name = 'DOX2';
      data = data ./ 1000000;
    
    % salinity (PSU)
    case 'sal00'
      name = 'PSAL';
    
    % turbidity (NTU)
    case 'obs'
      name = 'TURB';
    
    % turbidity (NTU)
    case 'upoly0'
      name = 'TURB';
    
    % depth (m)
    case 'depSM'
      name = 'DEPTH';
    
    % depth (m)
    case 'depFM'
      name = 'DEPTH';
    
    otherwise 
      name = '';
      data = [];
  end
end

function time = genTimestamps(instHeader, fileHeader, data)
%GENTIMESTAMPS Generates timestamps for the data. Horribly ugly. I shouldn't 
% have to have a function like this, but the .cnv files do not necessarily 
% provide timestamps for each sample.
%
  time = [];
  
  % To generate timestamps for the CTD data, we need to know:
  %   - start time
  %   - sample interval
  %   - number of samples
  %
  % The SBE19 header information does not necessarily provide all, or any
  % of this information. .
  %
  start    = 0;
  interval = 0.25;
  nSamples = 0;
    
  % figure out number of samples by peeking at the 
  % number of values in the first column of 'data'
  f = fieldnames(data);
  nSamples = length(data.(f{1}));
  
  % try and find a start date - use castDate if present
  if isfield(instHeader, 'castDate')
    start = instHeader.castDate;
  end
  
  % if scanAvg field is present, use it to determine the interval
  if isfield(instHeader, 'scanAvg')
    
    interval = (0.25 * instHeader.scanAvg) / 86400;
  end
  
  % if one of the columns is 'Scan Count', use the 
  % scan count number as the basis for the timestamps 
  if isfield(data, 'ScanCount')
    
    time = ((data.ScanCount - 1) ./ 345600) + cStart;
  
  % if scan count is not present, calculate the 
  % timestamps from start, end and interval
  else
    
    time = (start:interval:start + (nSamples - 1) * interval)';
  end
end
