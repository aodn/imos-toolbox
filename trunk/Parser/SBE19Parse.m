function sample_data = SBE19Parse( filename )
%SBE19PARSE Parses a converted (.cnv) data file from a Seabird SBE19plus V2 
% CTD recorder.
%
% This function is able to read in a converted (.cnv) data file retrieved 
% from a Seabird SBE19plus V2 CTD recorder. The Seabird SBE Data Processing 
% program is able to genearted .cnv files from raw .hex and .con files; the
% resulting .cnv file consists of three sections:
%
%   - raw header       - header information as retrieved from the instrument. 
%                        These lines are prefixed with '*'.
%   - processed header - header information generated by SBE Data Processing. 
%                        These lines are prefixed with '#'.
%   - data             - Rows of space separated data
%
% The parameters contained in the .cnv file is configurable via the SBE 
% Data Processing program. This function accepts the following parameters; 
% the parameter must be provided in the listed unit of measurement:
%
%   - Temperature (deg C)
%   - Conductivity (S/m, mS/cm, uS/cm)
%   - Turbidity/Backscatterance (NTU)
%   - Pressure (db)
%   - Fluorescence (ug/L)
%   - Oxygen (mg/L, umol/kg)
%   - Salinity (PSU)
%
% Inputs:
%   filename    - cell array of files to import (only one supported).
%
% Outputs:
%   sample_data - Struct containing sample data.
%
% Author: Paul McCarthy <paul.mccarthy@csiro.au>
%

%
% Copyright (c) 2009, eMarine Information Infrastructure (eMII) and Integrated 
% Marine Observing System (IMOS).
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without 
% modification, are permitted provided that the following conditions are met:
% 
%     * Redistributions of source code must retain the above copyright notice, 
%       this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright 
%       notice, this list of conditions and the following disclaimer in the 
%       documentation and/or other materials provided with the distribution.
%     * Neither the name of the eMII/IMOS nor the names of its contributors 
%       may be used to endorse or promote products derived from this software 
%       without specific prior written permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
% POSSIBILITY OF SUCH DAMAGE.
%
  error(nargchk(1,1,nargin));

  if ~iscellstr(filename)
    error('filename must be a cell array of strings'); 
  end

  % only one file supported currently
  filename = filename{1};
  
  % we put the sections into separate cell arrays
  instHeaderLines = {};
  fileHeaderLines = {};
  dataLines       = {};
  
  fid = -1;
  try
    fid = fopen(filename);
    % read in all the lines, putting them 
    % into the appropriate cell array
    line = fgetl(fid);
    
    while ischar(line)
      
      line = deblank(line);
      if isempty(line)
        line = fgetl(fid);
        continue; 
      end
      
      switch line(1)
        case '*',  instHeaderLines{end+1} = line;
        case '#',  fileHeaderLines{end+1} = line;
        otherwise, dataLines      {end+1} = line;
      end
      
      line = fgetl(fid);
    end
    fclose(fid);
    
  catch e
    if fid ~= -1, fclose(fid); end
    rethrow(e);
  end
  
  % parse the various sections
  instHeader = parseInstrumentHeader(instHeaderLines);
  fileHeader = parseFileHeader(fileHeaderLines);
  data       = parseData(dataLines, fileHeader);
    
  % if there is no time data in the file,
  % generate time stamps for each sample
  if ~isfield(data, 'Time')
    data.Time = genTimestamps(instHeader, fileHeader, data);
  end
  
  % create sample data struct
  sample_data = struct;
  
  sample_data.meta.instrument_make      = 'Seabird';
  sample_data.meta.instrument_model     = instHeader.instrument_model;
  sample_data.meta.instrument_firmware  = instHeader.instrument_firmware;
  sample_data.meta.instrument_serial_no = instHeader.instrument_serial_no;
  
  sample_data.dimensions         = {};
  sample_data.dimensions{1}.name = 'TIME';
  sample_data.dimensions{1}.data = data.Time;
  
  sample_data.variables = {};
  
  % scan through the list of parameters that were read 
  % from the file, and create a variable for each
  vars = fieldnames(data);
  for k = 1:length(vars)
    
    [n, d] = convertData(vars{k}, data.(vars{k}));
    
    if isempty(n) || isempty(d), continue; end;
    
    sample_data.variables{end+1}.dimensions = [1];
    sample_data.variables{end  }.name       = n;
    sample_data.variables{end  }.data       = d;
  end
end


function header = parseInstrumentHeader(headerLines)
%PARSEINSTRUMENTHEADER Parses the header lines from an SBE 19 file. Returns 
% the header information in a struct.
%
% Inputs:
%   headerLines - cell array of strings, the lines of the header section.
%
% Outputs:
%   header      - struct containing information that was in the header
%                 section.
%
  header = struct;

  % there's no real structure to the header information, which 
  % is annoying. my approach is to use various regexes to search 
  % for info we want, and to ignore everything else. inefficient,
  % but it's the nicest way i can think of
  headerExpr   = '^\*\s*(SBE \S+|SeacatPlus)\s+V\s+(\S+)\s+SERIAL NO.\s+(\d+)';
  scanExpr     = 'number of scans to average = (\d+)';
  memExpr      = 'samples = (\d+), free = (\d+), casts = (\d+)';
  sampleExpr   = ['sample interval = (\d+) (\w+), ' ...
                  'number of measurements per sample = (\d+)'];
  modeExpr     = 'mode = (\w+)';
  pressureExpr = 'pressure sensor = (strain gauge|quartz)';
  voltExpr     = 'Ext Volt (\d+) = (yes|no)';
  outputExpr   = 'output format = (.*)$';
  castExpr     = ['(?:cast|hdr)\s+(\d+)\s+' ...
                  '(\d+ \w+ \d+ \d+:\d+:\d+)\s+'...
                  'samples (\d+) to (\d+), (?:avg|int) = (\d+)'];
  
  exprs = {...
    headerExpr   scanExpr     ...
    memExpr      sampleExpr   ...
    modeExpr     pressureExpr ...
    voltExpr     outputExpr   ...
    castExpr};
  
  for k = 1:length(headerLines)
    
    % try each of the expressions
    for m = 1:length(exprs)
      
      % until one of them matches
      tkns = regexp(headerLines{k}, exprs{m}, 'tokens');
      if ~isempty(tkns)
        
        % yes, ugly, but easiest way to figure out which regex we're on
        switch m
          
          % header
          case 1
            header.instrument_model     = tkns{1}{1};
            header.instrument_firmware  = tkns{1}{2};
            header.instrument_serial_no = tkns{1}{3};
            
          % scan
          case 2
            header.scanAvg = str2double(tkns{1}{1});
          
          % mem
          case 3
            header.numSamples = str2double(tkns{1}{1});
            header.freeMem    = str2double(tkns{1}{2});
            header.numCasts   = str2double(tkns{1}{3});
            
          % sample
          case 4
            header.sampleInterval        = str2double(tkns{1}{1});
            header.mesaurementsPerSample = str2double(tkns{1}{2});
            
          % mode
          case 5
            header.mode = tkns{1}{1};
          
          % pressure
          case 6
            header.pressureSensor = tkns{1}{1};
            
          % volt
          case 7
            for n = 1:length(tkns), 
              header.(['ExtVolt' tkns{n}{1}]) = tkns{n}{2};
            end
            
          % output
          case 8
            header.outputFormat = tkns{1}{1};
            
          % cast
          case 9
            header.castNumber = str2double(tkns{1}{1});
            header.castDate   = datenum(tkns{1}{2}, 'dd mmm yyyy HH:MM:SS');
            header.castStart  = str2double(tkns{1}{3});
            header.castEnd    = str2double(tkns{1}{4});
            header.castAvg    = str2double(tkns{1}{5});
        end
        break;
      end
    end
  end
end

function header = parseFileHeader(headerLines)
%PARSEFILEHEADER Parses the data contained inthe file header. This includes
% the column layout of the data in the .cnv file.
%
% Inputs:
%   headerLines - Cell array of strings, the lines in the file header section.
%
% Outputs:
%   header      - struct containing information that was contained in the
%                 file header section.
%

  header = struct;
  header.columns = {};
  
  nameExpr = 'name \d+ = (.+):';
  nvalExpr = 'nvalues = (\d+)';
  badExpr  = 'bad_flag = (.*)$';
  
  for k = 1:length(headerLines)
    
    % try name expr
    tkns = regexp(headerLines{k}, nameExpr, 'tokens');
    if ~isempty(tkns)
      header.columns{end+1} = tkns{1}{1};
      continue; 
    end
    
    % then try nvalues expr
    tkns = regexp(headerLines{k}, nvalExpr, 'tokens');
    if ~isempty(tkns)
      header.nValues = str2double(tkns{1}{1});
      continue;
    end
    
    % then try bad flag expr
    tkns = regexp(headerLines{k}, badExpr, 'tokens');
    if ~isempty(tkns)
      header.badFlag = str2double(tkns{1}{1});
      continue;
    end
  end
end

function data = parseData(dataLines, fileHeader)
%PARSEDATA Parses the data section of the .cnv file.
%
% Inputs:
%   dataLines  - cell array of strings, the lines containing the data.
%   fileHeader - struct containing file header information.
%
% Outputs:
%   data       - struct containing the data.
%
  
  data = struct;
  
  format = '';
  
  columns = fileHeader.columns;
  for k = 1:length(columns), format = [format '%n']; end
  
  dataLines = [dataLines{:}];
  
  dataLines = textscan(dataLines, format);
  
  for k = 1:length(columns)
    
    d = dataLines{k};
    d(d == fileHeader.badFlag) = nan;
    data.(genvarname(columns{k})) = d; 
  end
  
end

function time = genTimestamps(instHeader, fileHeader, data)
%GENTIMESTAMPS Generates timestamps for the data. Horribly ugly. I shouldn't 
% have to have a function like this, but the SBE19 .cnv files do not provide 
% timestamps for each sample.
%
  time = [];
  
  cStart = instHeader.castDate;
  cInt   = (0.25 * instHeader.scanAvg) / 86400;
  cEnd   = instHeader.castDate + (cInt * (fileHeader.nValues - 1));

  % if one of the columns is 'Scan Count', use the 
  % scan count number as the basis for the timestamps 
  if isfield(data, 'ScanCount')
    
    time = ((data.ScanCount - 1) ./ 345600) + cStart;
  
  % if scan count is not present, calculate the 
  % timestamps from start, end and interval
  else
    
    time = (cStart:cInt:cEnd)';
  end
end

function [name, data] = convertData(name, data) 
%CONVERTDATA The SBE19 provides data in a bunch of different units of
% measurement. This function is just a big switch statement which takes
% SBE19 data as input, and attempts to convert it to IMOS compliant name and 
% unit of measurement. Returns empty string/vector if the parameter is not 
% supported.
%

  switch name
    
    % strain gauge pressure (dbar)
    case 'prdM'
      name = 'PRES';
      
    % temperature (deg C)
    case 'tv290C'
      name = 'TEMP';
      
    % conductivity (S/m)
    case 'c0S0x2Fm'
      name = 'CNDC';
    
    % conductivity (mS/cm)
    % mS/cm -> S/m
    case 'c0ms0x2Fcm'
      name = 'CNDC';
      data = data ./ 10;
    
    % conductivity (uS/cm)
    case 'c0us0x2Fcm'
      name = 'CNDC';
      data = data ./ 100000;
    
    % fluorescence (ug/L)
    % ug/L == mg/m^-3
    case 'flC'
      name = 'FLU2';
      
    % oxygen (mg/L)
    % mg/L == kg/m^-3
    case 'oxsolMg0x2FL'
      name = 'DOXY';
    
    % oxygen (umol/Kg)
    % umol/Kg -> mol/Kg
    case 'oxsolMm0x2FKg'
      name = 'DOX2';
      data = data ./ 1000000;
      
    % oxygen (mg/L)
    % mg/L == kg/m^-3
    case 'oxsatMg0x2FL'
      name = 'DOXY';
      
    % oxygen (umol/Kg)
    % umol/Kg -> mol/Kg
    case 'oxsatMm0x2FKg'
      name = 'DOX2';
      data = data ./ 1000000;
    
    % oxygen (mg/L)
    % mg/L == kg/m^-3
    case 'sbeox0Mg0x2FL'
      name = 'DOXY';
      
    % oxygen (umol/Kg)
    % umol/Kg -> mol/Kg
    case 'sbeox0Mm0x2FKg'
      name = 'DOX2';
      data = data ./ 1000000;
    
    % salinity (PSU)
    case 'sal00'
      name = 'PSAL';
    
    % turbidity (NTU)
    case 'obs'
      name = 'TURB';
      
    otherwise 
      name = '';
      data = [];
  end
end
