function sample_data = SBE19Parse( filename )
%SBE19PARSE Parses a converted (.cnv) data file from a Seabird SBE19plus V2 
% CTD recorder.
%
% This function is able to read in a converted (.cnv) data file retrieved 
% from a Seabird SBE19plus V2 CTD recorder. The Seabird SBE Data Processing 
% program is able to genearted .cnv files from raw .hex and .con files; the
% resulting .cnv file consists of three sections:
%
%   - raw header       - header information as retrieved from the instrument. 
%                        These lines are prefixed with '*'.
%   - processed header - header information generated by SBE Data Processing. 
%                        These lines are prefixed with '#'.
%   - data             - Rows of space separated data
%
% The parameters contained in the .cnv file is configurable via the SBE 
% Data Processing program. This function accepts the following parameters; 
% the parameter must be provided in the listed unit of measurement:
%
%   - Temperature (ITS 90, Degrees Celsius)
%   - Conductivity (S/m)
%   - Pressure (db)
%   - Fluorescence (ug/L)
%   - Oxygen (mg/L)
%   - Salinity (PSU)
%
% Inputs:
%   filename    - cell array of files to import (only one supported).
%
% Outputs:
%   sample_data - Struct containing sample data.
%
% Author: Paul McCarthy <paul.mccarthy@csiro.au>
%

%
% Copyright (c) 2009, eMarine Information Infrastructure (eMII) and Integrated 
% Marine Observing System (IMOS).
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without 
% modification, are permitted provided that the following conditions are met:
% 
%     * Redistributions of source code must retain the above copyright notice, 
%       this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright 
%       notice, this list of conditions and the following disclaimer in the 
%       documentation and/or other materials provided with the distribution.
%     * Neither the name of the eMII/IMOS nor the names of its contributors 
%       may be used to endorse or promote products derived from this software 
%       without specific prior written permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
% POSSIBILITY OF SUCH DAMAGE.
%
  error(nargchk(1,1,nargin));

  if ~iscellstr(filename)
    error('filename must be a cell array of strings'); 
  end

  % only one file supported currently
  filename = filename{1};
  
  % we put the sections into separate cell arrays
  instHeaderLines = {};
  fileHeaderLines = {};
  dataLines       = {};
  
  fid = -1;
  try
    fid = fopen(filename);
    % read in all the lines, putting them 
    % into the appropriate cell array
    line = fgetl(fid);
    
    while ischar(line)
      
      line = deblank(line);
      if isempty(line)
        line = fgetl(fid);
        continue; 
      end
      
      switch line(1)
        case '*',  instHeaderLines{end+1} = line;
        case '#',  fileHeaderLines{end+1} = line;
        otherwise, dataLines      {end+1} = line;
      end
      
      line = fgetl(fid);
    end
    fclose(fid);
    
  catch e
    if fid ~= -1, fclose(fid); end
    rethrow(e);
  end
  
  % parse the various sections
  instHeader = parseInstrumentHeader(instHeaderLines);
  fileHeader = parseFileHeader(fileHeaderLines);
  data       = parseData(dataLines, fileHeader);
    
  % if profiling mode, generate time stamps for each sample
  if strcmp(instHeader.mode, 'profile')
    
    cStart = instHeader.castDate;
    cInt   = (0.25 * instHeader.scanAvg) / 86400;
    cEnd   = instHeader.castDate + (cInt * (instHeader.numSamples - 1));
  
    data.Time = (cStart:cInt:cEnd)';
  end
  
  % create sample data struct
  sample_data = struct;
  
  sample_data.meta.instrument_make      = 'Seabird';
  sample_data.meta.instrument_model     = instHeader.instrument_model;
  sample_data.meta.instrument_firmware  = instHeader.instrument_firmware;
  sample_data.meta.instrument_serial_no = instHeader.instrument_serial_no;
  
  sample_data.dimensions         = {};
  sample_data.dimensions{1}.name = 'TIME';
  sample_data.dimensions{1}.data = data.Time;
  
  sample_data.variables = {};
  
  % scan through the list of parameters that were read 
  % from the file, and create a variable for each
  vars = fieldnames(data);
  for k = 1:length(vars)
    
    divisor = 1;
        
    switch vars{k}
      case 'Temperature'
        sample_data.variables{end+1}.name = 'TEMP';
        
      case 'Conductivity'
        sample_data.variables{end+1}.name = 'CNDC';
        
      case 'Pressure'
        sample_data.variables{end+1}.name = 'PRES';
        
      case 'Salinity'
        sample_data.variables{end+1}.name = 'PSAL';
        
      case 'Fluorescence'
        sample_data.variables{end+1}.name = 'FLU2';
      
      % oxygen requires conversion from mg/L to kg/m^3
      case 'Oxygen'
        sample_data.variables{end+1}.name = 'DOXY';
        divisor = 1000.0;
        
      otherwise, continue;
    end
    
    sample_data.variables{end}.dimensions = [1];
    sample_data.variables{end}.data       = data.(vars{k}) ./ divisor;
  end
end


function header = parseInstrumentHeader(headerLines)
%PARSEINSTRUMENTHEADER Parses the header lines from an SBE 19 file. Returns 
% the header information in a struct.
%
% Inputs:
%   headerLines - cell array of strings, the lines of the header section.
%
% Outputs:
%   header      - struct containing information that was in the header
%                 section.
%
  header = struct;

  % there's no real structure to the header information, which 
  % is annoying. my approach is to use various regexes to search 
  % for info we want, and to ignore everything else. inefficient,
  % but it's the nicest way i can think of
  headerExpr   = '^\*\s*(SBE \S+|SeacatPlus)\s+V\s+(\S+)\s+SERIAL NO.\s+(\d+)';
  scanExpr     = 'number of scans to average = (\d+)';
  memExpr      = 'samples = (\d+), free = (\d+), casts = (\d+)';
  sampleExpr   = ['sample interval = (\d+) (\w+), ' ...
                  'number of measurements per sample = (\d+)'];
  modeExpr     = 'mode = (\w+)';
  pressureExpr = 'pressure sensor = (strain gauge|quartz)';
  voltExpr     = 'Ext Volt (\d+) = (yes|no)';
  outputExpr   = 'output format = (.*)$';
  castExpr     = ['(?:cast|hdr)\s+(\d+)\s+' ...
                  '(\d+ \w+ \d+ \d+:\d+:\d+)\s+'...
                  'samples (\d+) to (\d+), (?:avg|int) = (\d+)'];
  
  exprs = {...
    headerExpr   scanExpr     ...
    memExpr      sampleExpr   ...
    modeExpr     pressureExpr ...
    voltExpr     outputExpr   ...
    castExpr};
  
  for k = 1:length(headerLines)
    
    % try each of the expressions
    for m = 1:length(exprs)
      
      % until one of them matches
      tkns = regexp(headerLines{k}, exprs{m}, 'tokens');
      if ~isempty(tkns)
        
        % yes, ugly, but easiest way to figure out which regex we're on
        switch m
          
          % header
          case 1
            header.instrument_model     = tkns{1}{1};
            header.instrument_firmware  = tkns{1}{2};
            header.instrument_serial_no = tkns{1}{3};
            
          % scan
          case 2
            header.scanAvg = str2double(tkns{1}{1});
          
          % mem
          case 3
            header.numSamples = str2double(tkns{1}{1});
            header.freeMem    = str2double(tkns{1}{2});
            header.numCasts   = str2double(tkns{1}{3});
            
          % sample
          case 4
            header.sampleInterval        = str2double(tkns{1}{1});
            header.mesaurementsPerSample = str2double(tkns{1}{2});
            
          % mode
          case 5
            header.mode = tkns{1}{1};
          
          % pressure
          case 6
            header.pressureSensor = tkns{1}{1};
            
          % volt
          case 7
            for n = 1:length(tkns), 
              header.(['ExtVolt' tkns{n}{1}]) = tkns{n}{2};
            end
            
          % output
          case 8
            header.outputFormat = tkns{1}{1};
            
          % cast
          case 9
            header.castNumber = str2double(tkns{1}{1});
            header.castDate   = datenum(tkns{1}{2}, 'dd mmm yyyy HH:MM:SS');
            header.castStart  = str2double(tkns{1}{3});
            header.castEnd    = str2double(tkns{1}{4});
            header.castAvg    = str2double(tkns{1}{5});
        end
        break;
      end
    end
  end
end

function header = parseFileHeader(headerLines)
%PARSEFILEHEADER Parses the data contained inthe file header. This includes
% the column layout of the data in the .cnv file.
%
% Inputs:
%   headerLines - Cell array of strings, the lines in the file header section.
%
% Outputs:
%   header      - struct containing information that was contained in the
%                 file header section.
%

  header = struct;
  header.columns = {};
  
  % all we're interested in is the column labels
  nameExpr = 'name \d+ = .+: (\w+)';
  
  for k = 1:length(headerLines)
    
    tkns = regexp(headerLines{k}, nameExpr, 'tokens');
    
    if isempty(tkns), continue; end
    
    header.columns{end+1} = tkns{1}{1};
    
  end
end

function data = parseData(dataLines, fileHeader)
%PARSEDATA Parses the data section of the .cnv file.
%
% Inputs:
%   dataLines  - cell array of strings, the lines containing the data.
%   fileHeader - struct containing file header information.
%
% Outputs:
%   data       - struct containing the data.
%
  
  data = struct;
  
  format = '';
  
  % length(columns)+1 - it is assumed that there is a 'flag' column
  columns = fileHeader.columns;
  for k = 1:length(columns)+1, format = [format '%n']; end
  
  dataLines = [dataLines{:}];
  
  dataLines = textscan(dataLines, format);
  
  for k = 1:length(columns), data.(columns{k}) = dataLines{k}; end
  
end
