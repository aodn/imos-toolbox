#summary Overview of Graph functions

<wiki:toc/>

= Graph Specification =

The Graph subdirectory provides functions which allow the user to plot and interact with data. The Graph subdirectory (and naming convention) is modularised down to groups of functions specific to graph and parameter types. An example Graph subdirectory is shown below:

 * `Graph/`
  * `graphTimeSeries.m`
  * `TimeSeries/`
   * `graphTimeSeriesX.m`
   * `graphTimeSeriesGeneric.m`
   * `highlightTimeSeriesX.m`
   * `highlightTimeSeriesGeneric.m`
   * `selectTimeSeriesX.m`
   * `selectTimeSeriesGeneric.m`
   * `flagTimeSeries.m`
   * `selectTimeSeriesGeneric.m`
  * `OtherGraph/`
   * `graphOtherGraphX.m`
   * `graphOtherGraphGeneric.m`
   * `highlightOtherGraphX.m`
   * `highlightOtherGraphGeneric.m`
   * `selectOtherGraphX.m`
   * `selectOtherGraphGeneric.m`
   * `flagOtherGraphX.m`
   * `flagOtherGraphGeneric.m`
  * ...
   
== `graph` functions ==

Functions of the name `graphX.m` (where `X` is the graph type) define the graphing options which are made available to the user. Each graph type has its own directory (e.g. `Graph/graphTimeSeries.m` is mapped to the `Graph/TimeSeries/` directory), which contains functions related to that graph type. The `graphX.m` functions use the `graphXY.m` functions to graph a set of variables.

Top level graph functions (i.e. `graphX.m`) have the following format:
{{{
function [graphs handles] = graphGraphType( parent, sample_data, vars )
}}}
where
 * `parent` is a handle to the parent GUI container (e.g. a `figure` or `uipanel`) in which to graph the data
 * `sample_data` is a struct containing the sample data
 * `vars` is a vector of indices into the `sample_data.variables` cell array, defining the variables which are to be graphed
 * `graphs` is a vector of axes handles
 * `handles` is a vector of data handles (e.g. `line`, `scatter`, `surface` etc).

Functions of the name `graphXY.m` (where `X` is the graph type and `Y` is the parameter) provide logic to graph a single variable. These functions have the following format:
{{{
function [h xLabel yLabel] = graphGraphTypeParameter( ax, sample_data, var )
}}}
where
 * `ax` is a handle to the axis in which the data should be graphed
 * `sample_data` is the struct containing the sample data
 * `var` is an index into the `sample_data.variables` cell array, defining the variable to be graphed.
 * `h` is a handle to the data that was graphed (e.g. `line`)
 * `xLabel` is a string containing the label to use for the x axis
 * `yLabel` is a string containing the label to use for the y axis

== `flag` functions ==

Functions of the name `flagX.m` and `flagXY.m` follow the same meaning and naming convention as the `graph` functions, except the purpose of the `flag` functions is to overlay QC flag data on existing graphs.

`flagX.m` functions have the following format:
{{{
function flags = flagTimeSeries( parent, graphs, sample_data, vars )
}}}
where
 * `parent` is a handle to the parent GUI container (e.g. a `figure` or `uipanel`)
 * `graphs` is a vector of handles to axis objects, one for each variable, in which to draw the flags
 * `sample_data` is a struct containing the sample data
 * `vars` is a vector of indices into the `sample_data.variables` cell array, the same lengths as `graphs`, defining the variables which are to be graphed
 * `flags` is a matrix of handles to the flags that were drawn (e.g. `scatter`). More than one handle may exist for each variable, thus a matrix is returned, with non-handle entries set to `0.0`.

`flagXY.m` functions have the following format:
{{{
function flags = flagGraphType( ax, sample_data, var )
}}}
where
 * `ax` is a handle to the axis on which the flag data should be drawn
 * `sample_data` is the struct containing the sample data
 * `var` is an index into `sample_data.variables` defining the variable for which flag data is to be drawn
 * `flags` is a vector of handles to the flags that were drawn (e.g. `scatter`), or an empty matrix, or `0.0` if no flags were drawn.

== `select` functions ==

Functions of the name `selectXY.m` (where `X` is the graph type, and `Y` is the parameter type) add logic to a graph which allows the user to select a range of data. These functions have the following format:
{{{
function selectTimeSeriesGeneric( selectCallback, clickCallback )
}}}
where
 * `selectCallback` is a handle to a function which is called when a region of data is selected. This function has the following format:
 {{{
function selectCallback(ax, type, range)
 }}}
 where
  * `ax` is a handle to the axis in question
  * `type` the value of the axis `SelectionType` property, which allows differentiation between left and right mous clicks.
  * `range` is a vector containing the coordinates of the selected data range.
 * `clickCallback` is a handle to a function which is called when a data point is clicked on. This function has the following format:
 {{{
function clickCallback(ax, type, point)
 }}}
 where
  * `ax` is a handle to the axis in question
  * `type` the value of the axis `SelectionType` property, which allows differentiation between left and right mous clicks.
  * `range` is a vector containing the coordinates of the data point which was clicked on.

== `highlight` functions ==

Functions of the name `highlightXY.m` (where `X` is the graph type, and `Y` is the parameter type) overlay a given data range onto an existing graph. These functions have the following format:
{{{
function highlight = highlightGraphTypeParameter( region, data )
}}}
where
 * `region` is a vector containing the data region to highlight
 * `data` is a handle, or vector of handles, to the graphics object(s) displaying the data (e.g. `line`, `scatter`)
 * `highlight` is a handle to the highlight graphic (e.g. `scatter`, `patch`)