#summary Specification of the Parser module.
#labels Specification

<wiki:toc max_depth="2"/>

= Parser =

== Overview ==

One parser file exists for each supported instrument. The file/function name is of the format `[instrument_name]Parse.m` where `[instrument_name]` is a unique name for the instrument. The file/function name format is important, as the list of supported instruments is automatically generated from files in the parser subdirectory which adhere to the file name format.

For example, the parser function to parse SBE37 data is contained in the file `SBE37Parse.m`; the function then, is called `SBE37Parse`.

== Function format ==

Parser functions must adhere to the following format, with regard to input and output arguments:

 `function sample_data = instParse ( raw_data_file )`

where:

  * `raw_data_file` is a cell array of strings, each entry of which is the name of a file or directory which contains the raw instrument data.
  * `sample_data` is a struct which contains the sample data and any metadata that was retrieved from the data file(s). `sample_data` may optionally be a cell array of structs, in the event that multiple data sets which cannot be combined have been read.

== Sample data ==

The `sample_data` struct must contain at least the following fields:

  * `meta`: Struct containing any metadata which was retrieved from the raw data file(s).
    * `instrument_make`: String containing the instrument manufacturer.
    * `instrument_model`: String containing the instrument model.
    * `instrument_serial_no`: String containing the instrument serial number.
  * `dimensions`: Cell array of structs containing dimension data:
    * `name`: (IMOS compliant) dimension name
    * `data`: Vector of dimension data (always one dimensional, so orientation does not matter)
  * `variables`: Cell array of structs:
    * `name`: (IMOS compliant) parameter name
    * `comment`: (optional) Any relevant comments about the data
    * `dimensions`: Vector of indices into the `sample_data.dimensions` array, indicating the dimensions of this data
    * `data`: Matrix of data (column vector if one-dimensional)

*Notes*

  * The contents of the name fields in both the `dimensions` and `variables` structs must follow the naming conventions outlined in the IMOS NetCDF User's Manual. 
  * All data must be in the corresponding IMOS unit of measurement for the parameter.
  * The order of the `variables.dimensions` array must be the same as the order of the indices into the `variables.data` matrix.
  * See the [DataStructures data structures spec] for more information.

=== Example ===

As an example, let's take the following hypothetical CTD data:

{{{
  time                 cond    temp   pressure
  2008-01-16 00:00:05  40.612  16.52  10.12
  2008-01-16 00:00:10  40.012  16.05  10.13
  2008-01-16 00:00:15  39.351  15.47  10.11
}}}

For this data, the `sample_data` struct would look like this (timestamps have been converted via the `datenum` function):

{{{
  >> sample_data

  sample_data = 

       variables: {[1x1 struct]  [1x1 struct]  [1x1 struct]}
      dimensions: {[1x1 struct]}

  >> sample_data.dimensions{1}

  ans =
      name: 'TIME'
      data: [7.3342e+05 7.3342e+05 7.3342e+05]

  >> sample_data.variables{1}

  ans = 

               name: 'TEMP'
         dimensions: 1
               data: [3x1 double]

  >> sample_data.variables{2}

  ans = 

               name: 'CNDC'
         dimensions: 1
               data: [3x1 double]

  >> sample_data.variables{3}

  ans = 

               name: 'PRES'
         dimensions: 1
               data: [3x1 double]
}}}

In the case that there are a different number of samples for different variables, the data fields should be padded so that all parameters have the same number of samples. For example, if we have the following data:

{{{
  time                 cond    temp   pressure
  2008-01-16 00:00:05  40.612  16.52  
  2008-01-16 00:00:10  40.012  16.05  10.13
  2008-01-16 00:00:15  39.351  15.47  
}}}

the conductivity and temperature variable structs would be identical to those above, but the pressure data would be padded with `0.0`'s